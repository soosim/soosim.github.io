# Soolife 工具库使用说明
> 维护人员: 潘景福    
> 创建时间: 2017-01-11   

[TOC]

## 1.Utils 工具类

### 引入命名空间

```c#
using Soolife;
```

### 直接调用方法的方式来使用
```c#
// 将字符串转换成 int，转换失败返回 null
int? result = Utils.ToInt32("123");
int? resultFailed = Utils.ToInt32("abc");

// 将对象转换成 JSON 格式字符串
// json 字符串内容为：
// {"ID":1,"Name":"Object Name"}
var obj = new
{
    ID = 1,
    Name = "Object Name"
};
string json = Utils.JsonSerialize(obj);
```

### 作为对应目标实例的扩展方法来使用

```c#
// 结果与上一节的例子一样
string input1 = "123";
string input2 = "abc";
int? result = input1.ToInt32();
int? resultFailed = input2.ToInt32();

var obj = new
{
    ID = 1,
    Name = "Object Name"
};
string json = obj.JsonSerialize();
```

> `扩展方法`的说明请参照 https://msdn.microsoft.com/zh-cn/library/bb383977.aspx



### 常用的工具方法汇总及使用技巧

> 工具类包含与业务无关的常用方法，可以随时补充



#### a) 数据类型转换

```c#
// ConvertTo 系列
// 将 object 转换成对应的类型并指定转换失败是返回的默认值
int result1 = Utils.ConvertTo(obj, 0);
int result2 = obj.ConvertTo(0);

// ToXxx 系列
// 尝试将string、DateTime、数值识别为其他类型的值或转换成其他格式
// 转换成 10 进制数
decimal d1 = "1.32".ToDecimal() ?? 0.0m;
// 将字符串的 IP 地址转换 int 值表示
int ipv4 = "220.12.23.34".ToIPv4() ?? 0;
// 将时间日期转换成 Unix 时间戳值
int timeStamp = DateTime.Now.ToUnixTimestamp();

```



#### b) 字符串编解码

```c#
// HtmlEncode/HtmlDecode (Html 编解码)
string input = "<script>alert('hello');</sciprt>";
// &lt;script&gt;alert(&apos;hello&apos;);&lt;/sciprt&gt;
string r1 = input.HtmlEncode();
// <script>alert('hello');</sciprt>
string r2 = r1.HtmlDecode();

// UrlEncode/UrlDecode (Url 编解码)
string url = "http://www.soolife.cn/";
// http%3a%2f%2fwww.soolife.cn%2f
string r1 = url.UrlEncode();
// http://www.soolife.cn/
string r2 = r1.UrlDecode();

// Base64Encode/Base64Decode (Base64 编解码)
string input = "Hello world!";
// SGVsbG8gd29ybGQh
string r1 = input.Base64Encode();
// Hello world!
string r2 = r2.Base64Decode();
```



#### c) 字符串数据格式验证

```c#
// 字符串是否仅包含0~9的数字
bool isDigit = "123456".IsDigit();	// true
bool isDigit = "a123456".IsDigit();	// false

// 字符串是否仅包含字幕或数字
bool isLetterOrDigit = "a123456".IsLetterOrDigit();	// true
bool isLetterOrDigit = "a123#456".IsLetterOrDigit();	// false

// 字符串是否是有效的 E-mail 地址
bool isEmail = "test@soolife.com.cn".IsEmail();	// true

// 字符串是否有效的 IPv4 地址
bool isIPv4 = "123.456.789.123".IsIPv4();	// false
```



#### d) 字符串加解密

```c#
// 对字符进行 MD5 哈希结算
// md5: E10ADC3949BA59ABBE56E057F20F883E
string md5 = "123456".MD5();

// 对字符串进行 SHA1 哈希运算
// sha1: 7C4A8D09CA3762AF61E59520943DC26494F8941B
string sha1 = "123456".SHA1();
```

#### e) C# 对象和 JSON 格式字符串的序列化/反序列化

```c#
// 实体类定义
// 使用 DataContract 和 DataMember 来自定字段序列化后的字段名
[DataContract]
public class ResultModel
{
    [DataMember(Name = "success")]
    public bool Success { get; set; }

    [DataMember(Name = "code")]
    public int Code { get; set; }

    [DataMember(Name = "message")]
    public string Message { get; set; }
}

// 将实体类数据转换成 JSON 字符串
ResultModel model = new ResultModel
{
    Success = true,
    Code = 0,
    Message = "成功"
};

// 将 model 序列化成 JSON 格式字符串
// {"success":true,"code":0,"message":"成功"}
string json = model.JsonSerialize();

// 将 JSON 格式字符串反序列化成 ResultModel 类型的实例
// m 与 model 包含相同的字段值
// JSON 无法成功反序列化为指定类型时，返回指定类型的默认值 default(ResultModel)
var m = json.JsonDeserialize<ResultModel>();
```



#### f) 配置文件内容的快速读取

```c#
// 读取 app.config / web.config 文件的 appSettings 配置项
// 不存在这个配置项时返回 ""
string redisServer = Utils.GetAppSetting("Redis_Server");

// 读取 app.config / web.config 文件的 connectionStrings 配置项
// 不存在这个配置项时返回 ""
string connectionString = Utils.GetConnectionString("Db_Product");
```



#### g) 文本文件的快速读取/保存

```c#
// 将字符串保存为文件
var r = Utils.SaveToFile("文件路径", "这里是要保存到文件的字符串内容");

// 从文件读取字符串
var c = Utils.ReadFromFile("文件路径");
```

小技巧：配合 JSON 序列化/反序列化实现配置的保存和读取
```c#
// 保存配置到文件
Config config = new Config
{
    ServerAddress = "172.16.1.29",
    ServerPort = 80,
    EnableSsl = true
};
Utils.SaveToFile("D:\\App\\Config.json");

// 下次可以很方便的读取配置
Config config = null;
var r = Utils.ReadFromFile("D:\\App\\Config.json");
if (r.Success)
{
    config = r.Data.JsonDeserialize<Config>();
}
if (config == null)
{
  	// Use default config
    config = new Config();
}
```



## 2.常用中间件操作接口

> 面向接口编程，而不是面向实现编程
>
> 这里将介绍怎么用这些接口来完成这些任务，而不必关系具体是怎么实现的



### a) 日志记录接口

```c#
using Soolife.Logger;

ILogger logger = ...;

// 记录调试信息(用于开发调试)
// ex 为关联的异常，默认为null
logger.Debug("调试信息", ex);

// 记录常规信息(普通的需要记录的信息)
logger.Info("信息", ex);

// 记录警告信息(对程序无影响，但应引起注意的信息)
logger.Warn("信息", ex);

// 记录错误信息(程序出错但能继续运行)
logger.Error("错误信息", ex);

// 记录致命错误(程序无法继续运行的致命错误)
logger.Fatal("致命错误", ex);
```

### b) 数据库操作接口

* 引入命名空间、获得接口实例

```c#
using Soolife.Data;

IDbHelper dbHelper = ...;
class User
{
    public int UserId { get; set}
    public string UserName { get; set; }
}
```

* 执行一个 SQL 查询并返回第一条记录或第一个值

```c#

// 执行一个 SQL 查询并返回单条记录为 User 实例
// 第二个参数的 new { UserId = 1 } 的字段值可以自动映射为 SQL 语句内的对应 @UserId 参数
// 无符合条件的记录时，返回 QueryFirstOrDefault<T> 类型参数 T 的默认值，这里的示例是 null
string sql = "SELECT UserId, UserName FROM Users WHERE UserId = @UserId";
var user = dbHelper.QueryFirstOrDefault<User>(sql, new { UserId = 1 });

// 执行一个 SQL 查询并返回单个值
string sql = "SELECT UserName FROM Users WHERE UserId = @UserId";
string username = dbHelper.QueryFirstOrDefault<string>(sql, new { UserId = 1 });

string sql = "SELECT COUNT(*) FROM Users";
int count = dbHelper.QueryFirstOrDefault<int>(sql);
```

* 执行一个 SQL 查询并返回一个结果集

```c#
// 查询 Users 表的所有记录
string sql = "SELECT UserId, UserName FROM Users";
IEnumerable<User> users = dbHelper.Query<User>(sql);
// 遍历记录
foreach (var user in users)
{
    Console.WriteLine(user.UserName);
}
```


* 执行一个 SQL 并返回受影响的行数

```c#
string sql = "UPDATE Users SET UserName = @UserName WHERE UserId = @UserId";
int count = dbHelper.Execute(sql, new { UserId = 1, UserName = "Jeffrey" });
```


* 执行一个 事务

> 使用 ExecuteTransaction(tran => {}) 来执行一个事务
>
> ExecuteTransaction 接受一个签名为 `Func<IDbTransactionHelper, bool>` 的回调函数
>
> ExecuteTransaction 会根据回调函数的返回值 true / false 自动管理事务的提交和回滚

```c#
var r = dbHelper.ExecuteTransaction(tran =>
{
    // tran 为 IDbTransactionHelper 接口实例
    // 在此上下文使用 tran 接口来执行数据库操作即在事务中执行
    // 两种情况下会导致事务 Rollback，否则都会自动 Commit
    // 1. return false;
    // 2. 此上下文中中抛出异常

    // 添加订单并获得订单的自增 ID
    string sql = "INSERT INTO Orders (OrderNo, Amount, CreateTime) VALUES (@OrderNo, @Amount, @CreateTime);SELECT LAST_INSERT_ID();";
    int orderId = tran.QueryFirstOrDefault<int>(sql, new
    {
        OrderNo = "201612201234",
        Amount = 120.00m,
        CreateTime = DateTime.Now.ToUnixTimestamp()
    });

    // 无法获取订单 ID 则回滚事务
    if (orderId <= 0)
    {
      	return false;
    }

    // 添加订单明细
    sql = "INSERT INTO OrderDetails (OrderId, SkuId, Price, Qty, CreateTime) (@OrderId, @SkuId, @Price, @Qty, @CreateTime)";
    tran.Execute(sql, new
    {
        OrderId = orderId,
        SkuId = 13999,
        Price = 89.00m,
        Qty = 1,
        CreateTime = DateTime.Now.ToUnixTimestamp()
    });

    // 事务成功，返回 true 会自动提交
    return true;

    // 假设有中间步骤执行出现异常，会导致事务自动回滚
    // 预料内的需要回滚的逻辑，请使用 return false 的方式，而不是刻意抛出异常。
    throw new Exception("出现异常自动回滚");
});
```


### C) 缓存存取接口
> 缓存子字段的说明：
1. 数据可以缓存存在一个缓存 Key 的主体或子字段中
2. 同一个缓存 key 作为一个整体自动过期或被删除

```c#
using Soolife.Cache;

ICacheProvider cache = ...;

// 从缓存获取一个缓存项目
CachedItem<User> cachedItem = cache.Get<User>("user:123");
// cachedItem == null, 缓存不存在此缓存项
// cachedItem.HasValue, 缓存项是否包含有效数据
User user = cachedItem.Value;

// 从缓存项目的子字段里获取一个缓存项目
CachedItem<UserInfo> cachedItem = cache.Get<UserInfo>("user:123", "info");
UserInfo userInfo = cachedItem.Value;

// 将一个数据保存在缓存项主体中
cache.Set("user:123", user, 600);

// 将一个数据保存在缓存项的子字段中
cache.Set("user:123, "info", userInfo, 600);

// 从缓存中删除一个或多个缓存 Key
cache.Remove("user:123", "user:456");

// 从一个缓存 Key 中删除一个或多个子字段
cache.RemoveFields("user:123", "info", "address");

```


### d) 消息队列操作接口

> 特别说明：
1. 在长时间运行的服务器应用中，仅需要在启动时调用 client.Connect() 来连接到 MQ 服务器，模块会自动保持连接并在断线后自动恢复连接
2. 仅在服务器应用退出的时候调用 client.Close() 和 client.Dispose() 来断开连接和释放资源

* 生产者操作接口

```c#
using Soolife.MQ;

static void Main(string[] args)
{
    IMQClient client = ...;

    try
    {
        // 连接到 MQ 服务器
        var result = client.Connect();
        if (!result.Success)
        {
            Console.WriteLine(result.Message);
            return;
        }

        // 获得消费者操作接口
        var r = client.CreateProducer("exchange.name");
        if (!r.Success)
        {
            Console.WriteLine(r.Message);
            return;
        }
        IMQProducer producer = r.Data;

        // 发送一条队列消息(任意字符串内容)
        var body = new
        {
            type = "paid",
            id = 1
        };
        var jsonBody = body.JsonSerialize();
        producer.Publish("routing.key", jsonBody);

        // 也提供了直接将 object 作为 JSON 字符串内容发送的接口
        producer.Publish("routing.key", body);

    }
    catch(Exception ex)
    {
        // 记录错误日志
        logger.Error(ex.Message, ex);
    }
    finally
    {
        client.Close();
        client.Dispose();
    }
}
```

* 消费者操作接口

```c#
using Soolife.MQ;

static void Main(string[] args)
{
    IMQClient client = ...;

    try
    {
        var result = client.Connect();
        if (!result.Success)
        {
            Console.WriteLine(result.Message);
            return;
        }

        // 获得消费者操作接口
        var r = client.CreateConsumer("queue.name");
        if (!r.Success)
        {
            Console.WriteLine(r.Message);
            return;
        }
        IMQConsumer consumer = r.Data;

        // 先绑定处理程序，然后开始接收队列消息
        consumer.Received += Data_Received;
        consumer.Start();

        // 保持程序运行
        Console.ReadKey();
    }
    catch(Exception ex)
    {
        // 记录错误日志
        logger.Error(ex.Message, ex);
    }
    finally
    {
        client.Close();
        client.Dispose();
    }
}

//
private static void Data_Received(object sender, DeliverEventArgs e)
{
    Console.WriteLine($"{e.RoutingKey}:{e.Body}");
}
```
> 消费者在接收到一条消息后，只有 consumer.Received 事件所有绑定的处理程序都处理完该消息（在该示例中等同于 Data_Received(sender, e) 执行一次结束）后，才会从队列接收下一条消息。



## 3.中间件接口的特定实现库

### a) 基于 Log4net 的日志写入接口实现
```c#
// NuGet 安装 Soolife.Logger.Log4net

using Soolife;
using Soolife.Logger;
using Soolife.Logger.Log4net;

// 配置名称对应 log4net 的配置项 <logger name="配置名称"></logger>
ILogger logger = new Log4netLogger("配置名称");
```


### b) 基于 MySql 的数据库操作接口实现
```c#
// NuGet 安装 Soolife.Data.MySql

using Soolife;
using Soolife.Data;
using Soolife.Data.MySql;

// 初始化一个新的 MySql 辅助类实例
IDbHelper dbHelper = new MySqlDbHelper(logger, "MySql 连接字符串");
```

### c) 基于 Redis 的缓存存取接口实现
```c#
// NuGet 安装 Soolife.Cache.Redis

using Soolife;
using Soolife.Cache;
using Soolife.Cache.Redis;

// 初始化一个新的 Redis 缓存存取接口类
ICacheProvider cache = new RedisCacheProvider(logger, "172.16.1.20:6379", "password");
```

### d) 基于 RabbitMQ 的消息队列接口实现
```c#
// NuGet 安装 Soolife.MQ.RabbitMQ

using Soolife;
using Soolife.MQ;
using Soolife.MQ.RabbitMQ;

// 初始化一个新的 RabbitMQ 消息队列接口实现类实例
// connectionName 为连接的客户端标识，用以标识连接到服务器的程序
IMQClient client = new RabbitMQClient(logger,
    "amqp://172.16.1.20:5672",
    "username",
    "password",
    connectionName: "Soolife Consumer");
```

## 4.修订记录

| 版本   | 日期        | 说明   | 修订人  |
| ---- | --------- | ---- | ---- |
| 0.1  | 2017-1-11 | 初版   | 潘景福  |
|      |           |      |      |
|      |           |      |      |


> © 2016 如此生活技术中心
