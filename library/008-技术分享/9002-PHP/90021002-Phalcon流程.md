# PHP 的闭包写法
> 维护人员: tony wang     
> 创建时间: 2016-12-20  

[TOC]

## 流程清单

为了方便查找，将整个流程整理为一个树形清单如下：
- 初始化DI (config/services.php) $di = new FactoryDefault();
  * 设置路由 $di['router'] = function () {}
  * 设置URL $di['url'] = function () {}
  * 设置Session $di['session'] = function () {}
- 初始化Application (public/index.php)
  * 实例化App $application = new Application();
  * 注入DI $application->setDI($di);
  * 注册模块 (config/modules.php) $application->registerModules()
- 启动Application (ext/mvc/application.c) $application->handle()
  * 检查DI
  * E 触发事件 application:boot
  * 路由启动 $di['router']->handle()
  * 获得模块名 $moduleName = $di['router']->getModuleName()，如果没有则从 $application->getDefaultModule获取
  * 模块启动 (如果路由命中)
    - E 触发事件 application:beforeStartModule
    - 调用模块初始化方法 (Module.php) registerAutoloaders() 以及 registerServices()
    - E 触发事件 application:afterStartModule
  * 分发
    - 初始化View
    - 初始化Dispatcher，将Router中的参数复制到Dispatcher
    - 调用View View->start()开启缓冲区
    - E 触发事件 application:beforeHandleRequest
    - 开始分发 (etc/dispatcher.c) Dispatcher->dispatch()
      * E 触发事件 dispatch:beforeDispatchLoop
      * 循环开始单次分发
        - E 触发事件 dispatch:beforeDispatch
        - 根据Dispatcher携带的Module、Namespace、Controller、Action获得完整的类与方法名，如果找不到则触发事件 E dispatch:beforeException
        - E 触发事件 dispatch:beforeExecuteRoute
        - 调用Controller->beforeExecuteRoute()
        - 调用Controller->initialize()
        - E 触发事件 dispatch:afterInitialize
        - 调用Action方法
        - E 触发事件 dispatch:afterExecuteRoute
        - E 触发事件 dispatch:afterDispatch
      * Action内如果有forward()，开始下一次分发
    - E 全部分发结束，触发事件 dispatch:afterDispatchLoop
    - Application获得分发后的输出 $dispatcher->getReturnedValue()
    - E 触发事件 application:afterHandleRequest 分发结束
  * 渲染，Appliction如果从分发拿到Phalcon\Http\ResponseInterface类型的返回，则渲染直接结束
    - E 触发事件 application:viewRender 分发结束
    - 调用 Phalcon\Mvc\View->render()，入口参数为Dispatcher的 ControllerName / ActionName / Params
    - 调用 Phalcon\Mvc\View->finish()结束缓冲区的接收
  * 准备响应
    - 将Phalcon\Mvc\View->getContent()通过Phalcon\Http\Response->setContent()放入Response
    - E 触发事件 application:beforeSendResponse
    - 调用Phalcon\Http\Response->sendHeaders()发送头部
    - 调用Phalcon\Http\Response->sendCookies()发送Cookie
    - 将准备好的响应作为$application->handle()的返回值返回
  * 发送响应
    - echo $application->handle()->getContent();


## MVC事件

Phalcon作为C扩展型的框架，其优势就在于高性能，虽然我们可以通过上一种方法自己实现整个启动，但更好的方式仍然是避免替换框架本身的内容，而使用事件驱动。

下面梳理了整个MVC流程中所涉及的可被监听的事件，可以根据不同需求选择对应事件作为切入点：

- DI注入
  * application:boot 应用启动
- 路由阶段
  * 模块启动
  * application:beforeStartModule 模块启动前
  * application:afterStartModule 模块启动后
- 分发阶段
  * application:beforeHandleRequest进入分发器前
  * 开始分发
    - dispatch:beforeDispatchLoop 分发循环开始前
    - dispatch:beforeDispatch 单次分发开始前
    - dispatch:beforeExecuteRoute Action执行前
    - dispatch:afterExecuteRoute Action执行后
    - dispatch:beforeNotFoundAction 找不到Action
    - dispatch:beforeException 抛出异常前
    - dispatch:afterDispatch 单次分发结束
    - dispatch:afterDispatchLoop 分发循环结束
  * application:afterHandleRequest 分发结束
- 渲染阶段
  * application:viewRender 渲染开始前
- 发送响应
  * application:beforeSendResponse 最终响应发送前



## 修订记录

| 版本   | 日期         | 说明   | 修订人  |
| ---- | ---------- | ---- | ---- |
| 0.1  | 2016-12-20 | 初版   | 汪肄敏  |
