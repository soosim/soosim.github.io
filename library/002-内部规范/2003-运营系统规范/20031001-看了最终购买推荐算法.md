# 看了最终购买推荐算法引擎 - 算法逻辑文档

> 维护人员: Tony Wang    
> 创建时间: 2016-12-28

内部资料 注意保密

## 一、SKU目录层级关系（SKU_GROUP）处理逻辑    
### 1.1数据源
商品目录横表（TDPA_B2C_CATENTRY_GRP_HORZ_TD）

### 1.2处理步骤
从商品目录横表（TDPA_B2C_CATENTRY_GRP_HORZ_TD）直接提取商品id（CATENTRY_ID）、一级目录id（CATGROUP1_ID）、二级目录id（CATGROUP2_ID）、三级目录id（CATGROUP3_ID）、四级目录id（CATGROUP4_ID）和五级目录id（CATGROUP5_ID）分别作为SKU目录关系层级表（SKU_GROUP）的SKU（SKU）、一级目录id（CATGROUP1_ID）、二级目录id（CATGROUP2_ID）、三级目录id（CATGROUP3_ID）、四级目录id（CATGROUP4_ID）和五级目录id（CATGROUP5_ID）。


## 二、SKU-SPU关系（SKU_SPU）处理逻辑    
### 2.1 数据源
- 商品颜色簇表（XCATENDESC2）
- 商品描述表（TDPA_B2C_CATENTRY_ATTR_TD）
- B2C订单表（TDPA_B2C_ORDER_ITEM）
- 商品目录横表（TDPA_B2C_CATENTRY_GRP_HORZ_TD）

### 2.2 处理步骤
- ①找到所有SKU：从商品描述表（TDPA_B2C_CATENTRY_ATTR_TD）找出所有商品id（CATENTRY_ID）作为SKU。  
- ②找到SKU与SPU对应关系：对于用步骤①取出的SKU用，商品目录横表（TDPA_B2C_CATENTRY_GRP_HORZ_TD）判断是否为图书，非图书SKU左关联商品颜色簇表（XCATENDESC2）的商品id（CATENTRY_ID）获得商品颜色簇表（XCATENDESC2）的簇ID(DESCRIPTION8)作为SKU的SPU，图书SKU默认没有簇，再对SPU进行重新编码作为最终的SPU。编码规则：首先从有簇ID(DESCRIPTION8)的SKU开始编码，对于有簇ID(DESCRIPTION8)的SKU，SPU编码从50001开始，同一簇ID(DESCRIPTION8)，SPU编码保持一致，不同簇ID(DESCRIPTION8)按升序编码；对于没有簇ID(DESCRIPTION8)的SKU,在已完成编码的SPU编码基础上继续升序编码，以保证不同SPU的SPU编码唯一。  
- ③计算SKU的SCORE值：首先，从B2C订单表（TDPA_B2C_ORDER_ITEM）中取出下单日期（TIME_RELEASED_DAY）在UTS设置参数日期或者算法运行开始日期和该日期前两个月（减2 MONTH）且订单状态为支付完成（C）、异常订单（e）、退货（r）的B2C订单作为计算SKU SCORE的基础数据。其次，以处理后的B2C订单表作为基础数据， 计算订单表中每个SKU(B2C订单表CATENTRY_ID)购买过的会员数（COUNT(DISTINCT(MEMBER_ID）。  
- ④用步骤②得到的SKU与SPU对应关系中SKU左关联步骤③中的SKU，得到SKU的SCORE值，关联不到SCORE值的SKU的SCORE值计0。  
- ⑤根据上述步骤处理，得到SKU与SPU的对应关系及SKU的SCORE值，结果保存在SKU_SPU表中，结束。  


## 三、商品组及其品类编号/销售目录（TDPA_B2C_CATENTRY_ATTR_TD）处理逻辑    
### 3.1数据源
- 商品组及其品类编号表 （TDPA_B2C_CATENTRY_ATTR_TD）
- 商品目录横表（TDPA_B2C_CATENTRY_GRP_HORZ_TD）

### 3.2处理步骤
取出商品SKU（Catentry_ID ）, 四级商品组ID（Catentry_Group_ID）--应用在电器类商品 , 三级销售目录ID (CATGROUP3_ID) -- 应用在图书类商品。


## 四、三级目录补全（TOP_C3）处理逻辑    
### 4.1数据源
- B2C订单表（TDPA_B2C_ORDER_ITEM）
- 商品描述表（TDPA_B2C_CATENTRY_ATTR_TD）
- 商品颜色簇表（XCATENDESC2）
- 商品目录横表（TDPA_B2C_CATENTRY_GRP_HORZ_TD）

### 4.2 处理步骤
- ①找到所有SKU：从商品描述表（TDPA_B2C_CATENTRY_ATTR_TD）找出所有商品id（CATENTRY_ID）作为SKU;
- ②找到SKU与SPU对应关系：用步骤①取出的SKU左关联商品颜色簇表（XCATENDESC2）的商品id（CATENTRY_ID）获得商品颜色簇表（XCATENDESC2）的簇ID(DESCRIPTION8)作为SKU的SPU，并对SPU进行重新编码作为最终的SPU。编码规则：首先从有簇ID(DESCRIPTION8)的SKU开始编码，对于有簇ID(DESCRIPTION8)的SKU，SPU编码从50001开始，同一簇ID(DESCRIPTION8)，SPU编码保持一致，不同簇ID(DESCRIPTION8)按升序编码；对于没有簇ID(DESCRIPTION8)的SKU,在已完成编码的SPU编码基础上继续升序编码，以保证不同SPU的SPU编码唯一。
- ③计算SKU的SCORE值：首先，从B2C订单表（TDPA_B2C_ORDER_ITEM）中取出下单日期（TIME_RELEASED_DAY）在最近下单日期（MAX（TIME_RELEASED_DAY））和最近下单日期前一个月（MAX（TIME_RELEASED_DAY）-1MONTH）,订单状态为支付完成（C）、异常订单（e）、退货（r）的B2C订单作为计算SKU SCORE的基础数据。其次，以处理后的B2C订单表作为基础数据， 计算订单表中每个SKU(B2C订单表CATENTRY_ID)购买过的会员数（COUNT(DISTINCT(MEMBER_ID))）。
- ④计算SPU的SCORE值：首先，根据第③操作得到的SKU及其SCORE值关联第②步操作得到的SKU与SPU对应关系中SKU得到，SKU、SPU及SCORE之间的关系；其次，以SPU为维度对SCORE进行汇总，就可以得到SPU的SCORE值。
- ⑤找到SPU与三级目录的关系：用第②步操作得到的SKU与SPU对应关系中的SKU关联SKU目录层级关系（SKU_GROUP）中的SKU得到SPU与三级目录之间的关系，得到SPU与三级目录关系表。
- ⑥找到SPU、三级目录、SCORE之间的关系：用第②步操作得到的SPU关联第④步操作结果中的SPU得到SPU、三级目录、SCORE三者之间的关系，并对三级目录进行，按SCORE值降序排列。如果三级目录SPU数大于等于500，则取SCORE前500的SPU；如果三级目录SPU数小于500，则取全部SPU。
- ⑦对SCORE值进行处理：首先，对第⑤操作得到的结果SCORE值归一化处理，归一化公式：，其中n为所有三级目录下的SPU；其次，将归一化之后的新SCORE值减1作为SPU最终的SCORE值。
- ⑧结束。


## 五、浏览最终购买关联矩阵（VIEW_THEN_BUY）处理逻辑
### 5.1数据源
- 基础数据访问表（TSA_SOR_PAGEVIEW）
- SA订单关联表（TSA_SOR_ORDER）
- B2C订单表（TDPA_B2C_ORDER_ITEM）
- SKU-SPU关系表（SKU_SPU）

### 5.2 处理步骤
- ①数据清洗：仅保留基础数据访问表（TSA_SOR_PAGEVIEW）中符合如下条件的数据：
一次会话（同一个VISIT_ID算一次会话）的四级页面（TO_PAGE_URL_PATTERN LIKE' '/prd_%为四级页面）数大于1小于500；
一次会话（同一个VISIT_ID算一次会话）购买的SKU数（通过SA订单关联表的PV_ID关联基础数据访问表的PV_ID得到订单号对应的会话VISIT_ID, SA订单关联表的ORDER_ID关联B2C订单表（不做任何处理）的ORDERS_ID，得到订单号对应的SKU(CATENTRY_ID)得到一次会话中购买的SKU数）小于50。


- ② Aprior算法：
算法输入：
通过SA订单表的PV_ID关联基础数据访问表的PV_ID得到有过购买记录的VISIT_ID看过的SKU（TO_PAGE_PARAM1），记作VISIT_VIEW_SKU1列表。
通过SA订单表的ORDER_ID关联B2C订单表（不做任何处理）的ORDERS_ID得到每个ORDER_ID购买的SKU（CATENTRY_ID），并通过SA订单表的PV_ID关联基础数据访问表的PV_ID得到有过购买记录的VISIT_ID，得到一次会话购买的SKU（CATENTRY_ID）,记作VISIT_BUY_SKU1列表。
状态c、r、e。
通过点击表（TSOR_BR_CLICK_D的PV_ID, PRMTR_ID_1）和基础访问表（TSOR_BR_BASE_PAGEVIEW_D）获得四级页面点击加入购物车，点击立即购买和点击一键购的VISIT_ID和购买的SKU（PAGE_PRMTR_1）,记作VISIT_BUY_SKU2列表。通过基础访问表获得该会话看过的SKU（TO_PAGE_PARAM1），记作VISIT_VIEW_SKU2列表。
合并VISIT_BUY_SKU1和VISIT_BUY_SKU2为VISIT_BUY_SKU，去除VISIT_ID和购买的SKU相同的记录；合并VISIT_VIEW_SKU1和VISIT_VIEW_SKU2为VISIT_VIEW_SKU，去除VISIT_ID和游览的SKU相同的记录。
算3天的。
  注：
  * 1）如果SKU是通码，转化为任意一个子码。
	* 2）过滤掉在销售商品信息表（DW_DPA.TDPA_CA_CATENTRY_INFO）中的字段pblsh=0的商品。

  计算关联度：
    其中，为计算周期内，a、b分别在同一个会话的VISIT_VIEW_SKU和VISIT_BUY_SKU列表中同时出现的次数。

    计算周期为一天（CREATE_DATE）
    计算示意图：
    ![]()

    图中的支持度即为关联度。
    **算法输出：**
      浏览最终购买SKU关联矩阵，包含SKU，关联SKU,SCORE。
    **具体形式为：**
      SKU{关联SKU1:SCORE1，关联SKU2:SCORE3，……}
    **汇总SKU关联矩阵：**
      按照算法输入的开始时间和结束时间以及周期 ,先计算计算周期结束日期前一天的SKU关联矩阵，然后再同前一个周期的SKU关联矩阵合并。合并规则： SKU列表合并，SCORE值累加。汇总之后，有的SKU关联列表会很长，为保证计算效率，按SCORE值降序排列，保留前100个SKU作为关联矩阵结果。

    **SKU关联矩阵转为SPU关联矩阵：**
      将汇总后的SKU关联矩阵根据SKU_SPU表，将SKU关联矩阵转为SPU关联矩阵。将同一个SPU关联SPU列表合并，SCORE值累加，并对合并后的SCORE值进行归一化处理。归一化公式：，将归一化后的SCROE值加3作为最终的SCORE。将SPU的关联SPU按归一化之后的SCORE值降序排列，如果关联SPU数大于等于100个，则取前100个关联SPU作为关联结果，否则取全部关联SPU作为关联结果，得到SPU浏览最终购买关联矩阵。

      最终的SPU浏览最终购买关联矩阵还需要利用短期模型来处理，具体方法参见步骤十。

## 六、用户点击的商品组/销售目录相似性的处理逻辑（Sim_Group2）
### 6.1 数据源
- 曝光信息表（TSOR_BR_EXPO_D）
- 点击表（TSOR_BR_CLICK_D）
- 基础数据访问表（TSA_SOR_PAGEVIEW）

### 6.2 处理步骤
- 1）统计一天内四级曝光页面中“看了最终购买”模块的主商品及其所有5个推荐商品的位置，点击次数，转化次数（加入购物车），得到T1。
- 2）累加最近的30天的所有四级曝光页面中“看了最终购买”模块的所有主商品及其5个推荐商品的位置，点击次数，转化次数（加入购物车），得到T2。
- 3）合并计算主商品组及其推荐商品组之间30天的推荐关系（主商品组/销售目录，推荐商品组/销售目录，位置，点击次数，转化次数），得到T3。
- 4）合并计算5个推荐位置的30天的商品组/销售目录之间推荐关系（主商品组/销售目录，推荐商品组/销售目录，点击次数，转化次数），得到T4。
- 5）每天计算上表中的转化率（=转化次数/点击数），得到T5。
- 7）针对一个主商品组/销售目录M1，取T5中的转化率最大的前5个推荐商品组/销售目录（不足5有多少取多少），降序排列，得到队列L1。
- 8）针对一个主商品组/销售目录M1，取T5中的点击数最大的前5个推荐商品组/销售目录（不足5有多少取多少），得到队列L2。
- 9）针对一个主商品组/销售目录M1，在用户游览并最终购买的商品组/销售目录相似性表（SIM_GROUP）中按相关性得分Score降序排列，得到队列L3， 取L3前5个相关商品组（不足5有多少取多少）。
- 10）融合L1，L2，和L3的队列到一个新的队列L4，具体步骤如下：
	* a）分别给L1，L2，和L3中的商品组打分，排名第一的分数为5，排名第5名的商品组得分为1；
	* b）累加L1，L2，和L3中共同出现的商品组得分，按得分降序排列所有商品组，得到队列L4；
- 11）针对一个主商品组/销售目录M1，根据同一品类推荐原则（看了最终购买的商品不得跨品类推荐），在同一品类中取前5个商品组，得到L5，若其数目小于5，有多少取多少。

注：若一个队列中的若干元素Score一样，则排序按照在L1，L2，和L3的队列中的先后顺序。

## 七、相似商品组/销售目录的处理逻辑（TOP_Sim_Group_2）
### 7.1数据源
用户点击的商品组/销售目录相似性表（SIM_GROUP2）

### 7.2 处理步骤
- 1）针对一个主商品组/销售目录M1，根据用户点击得到的相关商品组/销售目录推荐队列L5，L5数目小于等于5。
- 2）若L5数目小于等于2，则直接被采用为队列L7；
- 3) 若L5数目等于5，则随机选取队列L5中的2个商品组/销售目录（不包含主商品组/销售目录M1）。随机算法如下：
  * a) 根据队列排序位置设计一个按比例的随机算法；
  * b) 设计一个序列L6总长为15, 第一位商品组/销售目录占用前5个位置，第二个商品组/销售目录占用接着的4个位置，直到最后一个商品组/销售目录占用最后1个位置；
  * c) 随机选取区间[1,15] 中的一个整数n1，选出L6中相应位置为n1的商品组/销售目录，从剩余的商品组/销售目录中得到新的队列L6’， 它的总长为10，第一位商品组/销售目录占用前4个位置，最后一个商品组/销售目录占用最后1个位置；  
	* d) 随机选取区间[1,10] 中的一个整数n2，选出L6’中相应位置为n2的商品组/销售目录，得到新的队列L6”；  
  * e) 根据如上步骤，依次选取直到选出第2个商品组/销售目录n2（不包含主商品组/销售目录M1），把n1和n2个商品组/销售目录重新按在L5中的原始顺序排列，得到新的队列L7。  
- 4）若L5商品组数目大于2小于5，假设为t，则随机选取队列L5中的2个商品组/销售目录（不包含主商品组/销售目录M1）。随机算法如下：
  * a) 根据队列排序位置设计一个按比例的随机算法；
  * b) 设计一个序列L6总长为, 第一位商品组/销售目录占用前t个位置，第二个商品组/销售目录占用接着的t-1个位置，直到最后一个商品组/销售目录占用最后1个位置；
  * c) 随机选取区间[1,] 中的一个整数n1，选出L6中相应位置为n1的商品组/销售目录，从剩余的商品组/销售目录中得到新的队列L6’， 它的总长为，第一位商品组/销售目录占用前t-1个位置，最后一个商品组/销售目录占用最后1个位置；
  * d) 随机选取区间[1,] 中的一个整数n2，选出L6’中相应位置为n2的商品组/销售目录，得到新的队列L6”；
  * e) 根据如上步骤，依次选取直到选出第2个商品组/销售目录n2（不包含主商品组/销售目录M1），把n1和n2个商品组/销售目录重新按在L5中的原始顺序排列，得到新的队列L7。  

## 八、最终推荐商品处理逻辑
### 8.1数据源
- 看了最终购买的关联矩阵（VIEW_THEN_BUY）
- 相似商品组/销售目录队列L7
- 销售商品信息表（DW_DPA.TDPA_CA_CATENTRY_INFO）

###8.2 处理步骤
- 1）针对一个主商品m1（SPU），从看了最终购买的关联矩阵（VIEW_THEN_BUY）中找到前100个推荐商品的队列s1（SPU），按Score值降序排列，不足100个有多少取多少。
- 2）针对m1根据商品组及其品类编号表（TDPA_B2C_CATENTRY_ATTR_TD）找到其商品组M1，根据TOP_Sim_Group_2随机生成一个队列L7，得到2个相似商品组（不包含主商品组/销售目录M1）。
- 3）在推荐商品的队列s1中过滤掉其商品组不在L7和M1中的商品，取剩下的前60个商品作为看了最终购买的推荐商品（SPU），得到推荐商品的队列s2，提供给产品部门。
- 4）如果在步骤3）中剩下的商品数不足60个，则利用相关三级目录补全表（TOP_C3）进行补全。

SPU相关三级目录补全：根据推荐商品的队列s2（SPU）及商品目录横表（TDPA_B2C_CATENTRY_GRP_HORZ_TD）关联得到推荐商品的队列s2的关联SPU的三级目录，以三级目录分组，对SCORE求和，将得到的三级目录SCORE值降序排列。
依次降序从一个相关三级目录中取出个商品（SPU），直到补齐60个为止（截止到的最后一个相关三级目录中取出的SPU个数可能小于等于个）。其中，n为商品队列s2中SPU的个数，m为商品队列s2中SPU所属的目录数， 计算结果取小于等于其结果的最大整数。从相关三级目录补全表（TOP_C3）取出SPU及SCORE之后，将取出的SCORE值加3作为三级目录组补全SPU的SCORE值。


## 九、最终推荐商品排序处理逻辑
### 9.1数据源
- 看了最终购买推荐商品（VIEW_THEN_BUY）
- 推荐算法推荐点击因素分析(看了还买)模型（MODEL）
- 商品挂牌价格表 （DW_SOR.TSOR_B2C_XLISTPRICE_D、DW_SOR.TSOR_FIS_CSHOP_PRICE_D）
- 商品描述信息表（BI_TD.TDPA_CA_CATENTRY_INFO）
- B2C订单表（TDPA_OR_ORDER_ITEM_CRNT_D）
- 商品目录信息横表（TDPA_B2C_CATENTRY_GRP_HORZ_TD）
- 价格分档表（数据挖掘平台价格偏好分档表UAI_OUT_GDS_GROU）

### 9.2 处理步骤
- 1）根据看了最终购买推荐商品（VIEW_THEN_BUY）的SPU和相关SKU的销量得到SKU推荐列表。根据推荐商品计算模型所需数据：是否同一商品组、主商品价格档次、主商品销量排名、关联得分、是否同一品牌、主商品销量档次、得分排序、推荐商品销量档次、价格档次差绝对值、推荐商品价格档次、销量档次差绝对值、推荐商品销量排名、是否同一三级目录、价格档次差、销量档次差。
其中：
  * 商品组、品牌取商品描述信息表（BI_TD.TDPA_CA_CATENTRY_INFO）数据；
  * 商品目录取商品目录信息横表（TDPA_B2C_CATENTRY_GRP_HORZ_TD）数据；
  * 商品价格取商品挂牌价格表 （DW_SOR.TSOR_B2C_XLISTPRICE_D、DW_SOR.TSOR_FIS_CSHOP_PRICE_D）数据；
  * 商品销量取B2C订单表（TDPA_OR_ORDER_ITEM_CRNT_D）数据（订单状态为支付完成（C））；
  * 价格档次是根据商品挂牌价格和价格偏好分档表计算；
  * 销量档次是按照销量的所在商品组和价格档次两个维度进行销量分档，同一商品组的同一价格档次按照销量的累计数量百分比1%、5%、12%、100%分为4个档次。
  根据以上数据作为模型计算数据（CLICK_FACTOR）。

  数据取值逻辑如下表
#### 选取的数据指标说明

| 中文字段    | 英文     | 说明     |
| :------------- | :------------- | :------------- |
| 主商品编码        | PAGE_PRMTR        | 主商品编码        |
| 推荐商品编码        | GDS_ID         |  推荐商品编码       |
| 主商品商品组        | A_GDS_GROUP_ID        | 主商品商品组编号        |
| 主商品品牌        | A_BRAND_ID        | 主商品品牌编号        |
| 主商品价格        | A_PRICE        | 当日主商品挂牌价格        |
| 主商品价格档次        | A_PRICE_NC        | 主商品价格档次        |
| 主商品价格排名        | A_PRICE_RANK        | 当日主商品价格在商品组内排名        |
| 推荐商品价格        | B_PRICE        | 当日推荐商品挂牌价格        |
| 推荐商品价格档次        | B_PRICE_NC        | 推荐商品价格档次        |
| 推荐商品价格排名        | B_PRICE_RANK        | 当日推荐商品价格在商品组内排名        |
| 主商品销量        | A_SALE_QTY        | 当日以及前29日的主商品销量        |
| 主商品销量档次        | A_QTY_NC        | 主商品销量档次        |
| 主商品销量排名        | A_QTY_RANK        | 主商品销量在商品组内排名排名        |
| 推荐商品销量        | B_SALE_QTY        | 当日及前29日的推荐商品销量        |
| 推荐商品销量档次        | B_QTY_NC        | 推荐商品销量档次        |
| 推荐商品销量排名        | B_QTY_RANK        | 推荐商品销量在商品组内的排名        |
| 推荐商品商品组        | B_GDS_GROUP_ID        | 推荐商品商品组        |
| 推荐商品品牌        | B_BRAND_ID        | 推荐商品品牌编码        |
| 关联得分        | SCORE        | view_then_buy最终购买关联得分        |
| 关联得分排名        | SCORE_RANK        | 关联得分在商品组内的排名        |
| 主商品三级目录        | A_CATGROUP3_ID        | 主商品三级目录编码        |
| 推荐商品三级目录        | B_CATGROUP3_ID        | 推荐商品三级目录编码        |
| 是否同一商品组        | IF_GROUP        | 是1，否0        |
| 是否同一品牌        | IF_BRAND        | 是1，否0        |
| 是否同一三级目录        | IF_CATGROUP3        | 是1，否0        |
| 价格档次差        | p2_p1        | 推荐商品价格档次-主商品价格档次        |
| 价格档次差的绝对值        | absp2_p1        | 价格档次差的绝对值        |
| 销量档次差        | Q2_Q1        | 推荐商品销量档次-主商品销量档次        |
| 销量档次差的绝对值        | absQ2_Q1        | 销量档次差的绝对值        |
|         |         |         |

- 2）针对推荐商品：按照下图逻辑，根据模型需求相关数据（CLICK_FACTOR）和推荐点击因素分析(看了还买)模型（MODEL）计算点击率，得到推荐商品的点击率，并按照点击率重新排序。
例:手机商品组模型：
泊松模型：
CLICK_RATE=EXP(-3.9344-0.1581*A_PRICE_NC-0.0735*B_PRICE_NC-3.1775E-05*A_QTY_RANK-1.1095*SCORE-0.0031*SCORE_RANK-1.9040*IF_GROUP+0.4187*IF_BRAND+2.8126*IF_CATGROUP3+0.0669*A_QTY_NC-0.0601*B_QTY_NC-0.1671*ABSP2_P1+0.0574*ABSQ2_Q1)
其中模型中各因素都是对点击影响显著的因素，例主商品价格档次A_PRICE_NC，系数是-0.1581，意义是主商品价格档次上升一个档次，推荐点击率下降0.85个千分点。
